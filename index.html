<!DOCTYPE html>
<html lang="en">
<link type="text/css" rel="stylesheet" href="style.css">

<head>
    <meta charset="UTF-8">
    <title>Three.js Gallery Room</title>
    <link rel="icon" type="image/x-icon" href="/assets/images/favicon3.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ojuju:wght@200..800&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <div id="blocker">
        <div class="flex-container">
            <div class="flex-child left">
                <div id="image">
                    <img src="assets/images/favicon2.ico" style="width:300px;">
                </div>
            </div>
            <div class="flex-child right">
                <div id="instructions">
                    <p style="font-size:50px; font-weight:700">
                        Click anywhere to explore
                    </p>
                    <p style="font-weight:300">
                        Move: WASD<br />
                        Look: MOUSE<br />
                        Esc: Pause
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
          }
        }
      </script>

    <script type="module">

        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let camera, scene, renderer, controls;
        let bowieModel, shieldModel, pusheenModel, froggyModel;
        let hand1, hand2;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        let raycaster;
        let floor;
        let baseReferenceSpace;
        let INTERSECTED;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const vertex = new THREE.Vector3();

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            scene.fog = new THREE.Fog(0xffffff, 0, 750);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
            //camera.position.set(2, 1.6, -10); // Adjust height to match your scene scale

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.addEventListener('sessionstart', () => {
                baseReferenceSpace = renderer.xr.getReferenceSpace();
                console.log(baseReferenceSpace);
                console.log(help);
            });
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            let vrButton = VRButton.createButton(renderer);
            document.body.appendChild(vrButton);
            vrButton.addEventListener('click', function () {
                //controls.lock();
            }, false);

            // hands
            controller1 = renderer.xr.getController(0);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            scene.add(controller2);

            const controllerModelFactory = new XRControllerModelFactory();
            const handModelFactory = new XRHandModelFactory();

            // Hand 1
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            hand1 = renderer.xr.getHand(0);
            hand1.add(handModelFactory.createHandModel(hand1));

            scene.add(hand1);

            // Hand 2
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            hand2 = renderer.xr.getHand(1);
            hand2.add(handModelFactory.createHandModel(hand2));
            scene.add(hand2);

            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, - 1)]);

            const line = new THREE.Line(geometry);
            line.name = 'line';
            line.scale.z = 5;

            //controller1.add( line.clone() );
            controller2.add(line.clone());

            raycaster = new THREE.Raycaster();

            hand2.addEventListener('pinchend', function () {

                if (INTERSECTED == undefined) return;

                console.log(INTERSECTED);
                //camera.position = intersections[0].point;
                //camera.position.x = intersections[0].point.x;
                //camera.position.z = intersections[0].point.z;

                //const offsetPosition = {x: intersections[0].x, y: intersections[0].y, z: intersections[0].z};
                const offsetPosition = { x: -INTERSECTED.x, y: 0.0, z: -INTERSECTED.z };
                //const offsetPosition = {x: 0.0, y: 0.0, z: -2.0};
                const offsetRotation = { x: 0, y: 0, z: 0, w: 1 };
                const transform = new XRRigidTransform(offsetPosition, offsetRotation);
                const teleportSpaceOffset = baseReferenceSpace.getOffsetReferenceSpace(transform);

                renderer.xr.setReferenceSpace(teleportSpaceOffset);


            });


            // Lighting
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            scene.add(directionalLight);


            // spotlight
            const spotLight = new THREE.SpotLight(0xffffff);
            spotLight.position.set(3, 1.5, 4);
            // spotLight.map = new THREE.TextureLoader().load( url );

            spotLight.castShadow = true;

            // spotLight.shadow.mapSize.width = 1024;
            // spotLight.shadow.mapSize.height = 1024;

            // spotLight.shadow.camera.near = 500;
            // spotLight.shadow.camera.far = 4000;
            // spotLight.shadow.camera.fov = 30;

            scene.add(spotLight);



            // Room creation
            createRoom();

            // Controls
            controls = new PointerLockControls(camera, renderer.domElement);

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            document.addEventListener('click', function () {
                controls.lock();
            }, false);

            controls.addEventListener('lock', function () {

                instructions.style.display = 'none';
                blocker.style.display = 'none';
                document.getElementById('octicon').style.filter = "invert(100%)";
            });

            controls.addEventListener('unlock', function () {

                blocker.style.display = 'block';
                instructions.style.display = '';
                document.getElementById('octicon').style.filter = "invert(0%)";
            });

            // scene.add(controls.getObject());

            const onKeyDown = function (event) {

                switch (event.code) {

                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = true;
                        break;

                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = true;
                        break;

                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = true;
                        break;

                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = true;
                        break;

                    case 'Space':
                        if (canJump === true) velocity.y += 350;
                        canJump = false;
                        break;

                }

            };

            const onKeyUp = function (event) {

                switch (event.code) {

                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = false;
                        break;

                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = false;
                        break;

                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = false;
                        break;

                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = false;
                        break;

                }

            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, - 1, 0), 0, 10);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function createRoom() {
            // Room dimensions and materials
            const roomGeometry = new THREE.BoxGeometry(100, 20, 100); // Example dimensions

            var groundTexture = new THREE.TextureLoader().load('assets/textures/oak.png');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(2500, 2500);
            groundTexture.encoding = THREE.sRGBEncoding;

            const floorMaterial = new THREE.MeshStandardMaterial({ map: groundTexture });
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF }); // White

            // Floor
            floor = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000), floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Walls
            // Adjust positions and rotations to create walls around the floor
            // Example for one wall:
            const wall = new THREE.Mesh(roomGeometry, wallMaterial);
            wall.position.set(0, 2, -5); // Adjust position according to your room dimensions
            // scene.add(wall);

            const column_radius = 0.2;
            const column_height = 0.8;
            const model_height = column_height + 0.4;

            const columnGeometry = new THREE.CylinderGeometry(column_radius, column_radius, column_height, 32);
            const columnMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });

            // bowie ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

            // Column (as a simple cylinder for this example)
            const column = new THREE.Mesh(columnGeometry, columnMaterial);
            column.position.set(3, column_height / 2.0, -5); // Position it on the floor
            scene.add(column);

            // load model
            const bowieloader = new GLTFLoader();
            bowieloader.load('assets/models/thisisbowie2.gltf', function (gltf) {
                gltf.scene.position.set(3, model_height, -5); // Adjust position to be on top of the column
                gltf.scene.rotation.x += 1.5;
                gltf.scene.scale.set(.2, .2, .2);
                scene.add(gltf.scene);
                bowieModel = gltf.scene;
            }, undefined, function (error) {
                console.error(error);
            });


            // ganon's shield ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

            // Column (as a simple cylinder for this example)
            const column1 = new THREE.Mesh(columnGeometry, columnMaterial);
            column1.position.set(5, column_height / 2.0, -5); // Position it on the floor
            scene.add(column1);

            // load model
            const shieldloader = new GLTFLoader();
            shieldloader.load('assets/models/ganon.gltf', function (gltf) {
                gltf.scene.position.set(5, model_height, -5); // Adjust position to be on top of the column
                gltf.scene.rotation.x += 4.75;
                gltf.scene.scale.set(.2, .2, .2);
                scene.add(gltf.scene);
                shieldModel = gltf.scene;
            }, undefined, function (error) {
                console.error(error);
            });

            // pusheen ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

            // Column (as a simple cylinder for this example)
            const column2 = new THREE.Mesh(columnGeometry, columnMaterial);
            column2.position.set(1, column_height / 2.0, -5); // Position it on the floor
            scene.add(column2);

            // load model
            const pusheenloader = new GLTFLoader();
            pusheenloader.load('assets/models/pusheen.gltf', function (gltf) {
                gltf.scene.position.set(1, model_height - 0.1, -5); // Adjust position to be on top of the column
                // gltf.scene.rotation.x += 1.5;
                gltf.scene.scale.set(.2, .2, .2);
                scene.add(gltf.scene);
                pusheenModel = gltf.scene;
            }, undefined, function (error) {
                console.error(error);
            });

            // froggy ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

            // Column (as a simple cylinder for this example)
            const column3 = new THREE.Mesh(columnGeometry, columnMaterial);
            column3.position.set(-1, column_height / 2.0, -5); // Position it on the floor
            scene.add(column3);

            // load model
            const froggyloader = new GLTFLoader();
            froggyloader.load('assets/models/disfroggy.gltf', function (gltf) {
                gltf.scene.position.set(-1, model_height + 0.1, -5); // Adjust position to be on top of the column
                // gltf.scene.rotation.x += 1.5;
                gltf.scene.scale.set(.2, .2, .2);
                scene.add(gltf.scene);
                froggyModel = gltf.scene;
            }, undefined, function (error) {
                console.error(error);
            });

        }

        function animate() {
            renderer.setAnimationLoop(render);
            return;

            requestAnimationFrame(animate);

            const time = performance.now();

            // if (controls.isLocked === true) {

            //     // raycaster.ray.origin.copy(controls.getObject().position);
            //     // raycaster.ray.origin.y -= 10;

            //     // const intersections = raycaster.intersectObjects(objects, false);

            //     // const onObject = intersections.length > 0;

            //     const delta = (time - prevTime) / 1000;

            //     velocity.x -= velocity.x * 10.0 * delta;
            //     velocity.z -= velocity.z * 10.0 * delta;

            //     velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

            //     direction.z = Number(moveForward) - Number(moveBackward);
            //     direction.x = Number(moveRight) - Number(moveLeft);
            //     direction.normalize(); // this ensures consistent movements in all directions

            //     if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
            //     if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

            //     // if (onObject === true) {

            //     //     velocity.y = Math.max(0, velocity.y);
            //     //     canJump = true;

            //     // }

            //     controls.moveRight(- velocity.x * delta);
            //     controls.moveForward(- velocity.z * delta);

            //     // controls.getObject().position.y += (velocity.y * delta); // new behavior

            //     // if (controls.getObject().position.y < 10) {

            //     //     velocity.y = 0;
            //     //     controls.getObject().position.y = 10;

            //     //     canJump = true;

            //     // }
            // }
            prevTime = time;

            render();
        }

        function render() {

            INTERSECTED = undefined;

            if (bowieModel) bowieModel.rotation.z += 0.01;
            if (shieldModel) shieldModel.rotation.z += 0.01;
            if (pusheenModel) pusheenModel.rotation.y += 0.01;
            if (froggyModel) froggyModel.rotation.y += 0.01;

            raycaster.setFromXRController(controller2);
            const intersects = raycaster.intersectObjects([floor]);
            if (intersects.length > 0) {
                INTERSECTED = intersects[0].point;
            }


            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

<footer><a href="https://github.com/bailey/gallery"><img src='./assets/octicon_white.png' id="octicon" width="40">

</html>